"""
The goal of this example is to create a model of power spectral densities
generated by the Jansen-Rit model, and to estimate parameters corresponding
to different PSDs.

- fsamp 500 Hz, win 4s, overlap 1s, Welsh PSD, log dB, 60 s data

"""

import numpy as np
import pylab as pl
import jax
import jax.numpy as jp
import jax.example_libraries.optimizers as jopt
import tqdm
import vbjax as vb

# first model will just be a single Jansen-Rit
def model(state, parameters):
    return vb.jr_dfun(state, 0, parameters)

# define a function to run the simulation & compute Welch PSD
def run_sim_psd(parameters, rng_key):

    # here we are choosing 4 parameters to optimize, but
    # it's best to look at the paper to select the best ones for your study
    A, B, a, b = parameters 

    # do a short simulation
    dt = 2.0 # ms == 500 Hz sampling frequency
    ntime = int(60e3 / dt)
    initial_state = jp.ones((6, 1))
    _, loop = vb.make_sde(dt=dt, dfun=model, gfun=1e-4)
    noise = vb.randn(ntime, *initial_state.shape, key=rng_key)
    parameters = vb.jr_default_theta._replace(A=A, B=B, a=a, b=b)
    states = loop(initial_state, noise, parameters)
    lfp = states[:, 1] - states[:, 0]
    lfp = jp.diff(lfp, axis=0) # remove 1/f

    # compute spectra
    win_size = int(4e3 / dt)
    overlap = win_size // 4 # 25 %
    ftfreq = jp.fft.fftfreq(win_size, dt) * 1e3 # kHz -> Hz

    windows = jp.array([lfp[i*overlap:i*overlap+win_size,0]
                        for i in range((len(lfp) - win_size)//overlap)])
    windows = windows * jp.hanning(win_size)
    windows_fft = jp.fft.fft(windows, axis=1)  # apply fft over time
    windows_psd = jp.mean(jp.abs(windows_fft), axis=0) # average power
    return ftfreq, windows_psd


# run sim for two example parameters
parameters = [
    (3.25, 22.0, 0.1, 0.05),
    (3.31, 22.5, 0.11, 0.049),
    ]
rng_keys = jax.random.split(jax.random.PRNGKey(1106), 2)
psds = [run_sim_psd(p, k) for p, k in zip(parameters, rng_keys)]

# show those psds
pl.figure()
ftfreq = psds[0][0]
for _, psd in psds:
    pl.semilogy(ftfreq[ftfreq>0], psd[ftfreq>0])
pl.xlim([0, 50])
pl.grid(1)
pl.legend([str(_) for _ in parameters])
pl.ylabel('PSD')
pl.xlabel('Hz')
pl.title('Example Simulated Welch PSD on 60s Jansen-Rit')

# as a first fit, we'll use 
# - sum square error as a loss function
# - the first simulated PSD above as the "data" to fit
# - PSD values in the band of 0 to 80 Hz

def loss_for_key(opt_params, rng_key):
    _, sim_psd = run_sim_psd(opt_params, rng_key)
    _, target_psd = psds[0]
    return jp.sum(jp.square(sim_psd - target_psd))

rng_keys = jax.random.split(jax.random.PRNGKey(1106), 32)

def loss(opt_params):
    losses = jax.vmap(lambda k: loss_for_key(opt_params, k))(rng_keys)
    assert losses.size == 32
    return jp.mean(losses)


# we start with a guess
init_params = 3.2, 22.1, 0.11, 0.051
print('loss on true', loss(parameters[0]))
print('initial loss', loss(init_params))
# choose learning rate / optimizer step size
lr = 1e-8
# create the optimizer (it returns 3 functions)
opt_init, opt_step, opt_get = jopt.adam(lr)
# create optimizer state
opt = opt_init(init_params)
# compile the loss function w/ gradients
vgloss = jax.jit(jax.value_and_grad(loss))
# do some steps
trace_loss = []
for i in (pbar := tqdm.trange(501)):
    v, g = vgloss(opt_get(opt))
    trace_loss.append(v)
    ng = jp.linalg.norm(jp.array(g))
    opt = opt_step(i, g, opt)
    pbar.set_description(f'loss {v:0.3f} ||g|| {ng:0.3f}')
final_params = opt_get(opt)
print('final params', final_params)

# plot the error during optimization
pl.figure(); pl.plot(trace_loss); pl.title('trace loss'); pl.grid(1)

# now show the opt sim fc found
pl.figure()
_, final_psd = run_sim_psd(final_params)
pl.semilogy(ftfreq[ftfreq>0], psds[0][1][ftfreq>0])
pl.semilogy(ftfreq[ftfreq>0], final_psd[ftfreq>0])
pl.xlim([0, 50])
pl.grid(1)
pl.legend(('Target', 'Fit'))
pl.ylabel('PSD')
pl.xlabel('Hz')
pl.title('Simulated PSDs & Fit')

pl.show()
