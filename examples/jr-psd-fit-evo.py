"""
The goal of this example is to create a model of power spectral densities
generated by the Jansen-Rit model, and to estimate parameters corresponding
to different PSDs.

- fsamp 500 Hz, win 4s, overlap 1s, Welsh PSD, log dB, 60 s data

"""

import time
import numpy as np
import pylab as pl
import vbjax as vb
import jax
import jax.numpy as jp
import jax.example_libraries.optimizers as jopt
import tqdm

# first model will just be a single Jansen-Rit
def model(state, parameters):
    return vb.jr_dfun(state, 0, parameters)

# define a function to run the simulation & compute Welch PSD
def run_sim_psd(parameters):

    # here we are choosing 4 parameters to optimize, but
    # it's best to look at the paper to select the best ones for your study
    A, B, a, b = parameters 

    # do a short simulation
    dt = 2.0 # ms == 500 Hz sampling frequency
    ntime = int(60e3 / dt)
    initial_state = jp.ones((6, 1))
    _, loop = vb.make_sde(dt=dt, dfun=model, gfun=1e-4)
    noise = vb.randn(ntime, *initial_state.shape)
    parameters = vb.jr_default_theta._replace(A=A, B=B, a=a, b=b)
    states = loop(initial_state, noise, parameters)
    lfp = states[:, 1] - states[:, 0]
    lfp = jp.diff(lfp, axis=0) # remove 1/f

    # compute spectra
    win_size = int(4e3 / dt)
    overlap = win_size // 4 # 25 %
    ftfreq = jp.fft.fftfreq(win_size, dt) * 1e3 # kHz -> Hz

    windows = jp.array([lfp[i*overlap:i*overlap+win_size,0]
                        for i in range((len(lfp) - win_size)//overlap)])
    windows = windows * jp.hanning(win_size)
    windows_fft = jp.fft.fft(windows, axis=1)  # apply fft over time
    windows_psd = jp.mean(jp.abs(windows_fft), axis=0) # average power
    return ftfreq, windows_psd


# run sim for two example parameters
parameters = [
    (3.25, 22.0, 0.1, 0.05),
    (3.31, 22.5, 0.11, 0.049),
    ]
psds = [run_sim_psd(_) for _ in parameters]

# show those psds
pl.figure()
ftfreq = psds[0][0]
for _, psd in psds:
    pl.semilogy(ftfreq[ftfreq>0], psd[ftfreq>0], 'xk')
pl.xlim([0, 50])
pl.grid(1)
pl.legend([str(_) for _ in parameters])
pl.ylabel('PSD')
pl.xlabel('Hz')
pl.title('Example Simulated Welch PSD on 60s Jansen-Rit')

# as a first fit, we'll use 
# - sum square error as a loss function
# - the first simulated PSD above as the "data" to fit
# - PSD values in the band of 0 to 80 Hz

freq_mask = (ftfreq > 2)*(ftfreq < 50)

def loss(opt_params):
    _, sim_psd = run_sim_psd(opt_params)
    sim_psd = sim_psd[freq_mask]
    # here we're using the 1st simulated example above as a target
    # but this would be replaced by some data
    _, target_psd = psds[0]
    target_psd = target_psd[freq_mask]
    # normalize
    sim_psd = sim_psd / jp.linalg.norm(sim_psd)
    target_psd = target_psd / jp.linalg.norm(target_psd)
    return jp.sum(jp.square(jp.log(sim_psd) - jp.log(target_psd)))

# compute loss & gradients on many parameters at once
vloss = jax.jit(jax.vmap(loss, in_axes=1))
pvloss = jax.pmap(jax.vmap(loss, in_axes=1))

# do a search for best params
rounds = 5000
round_size = 32
zs = vb.randn(rounds, 4, round_size)
bsf_params = jp.array(parameters[0])*2
bsf = vloss(bsf_params[:,None]).min()
sdseq = 0.2/2**np.r_[:20]
tik = time.time()
for i in (pbar := tqdm.trange(rounds)):
    sd = sdseq[i//2000]
    p = bsf_params[:,None]*(1 + sd*zs[i])
    pp = p.reshape(4, vb.cores, -1).transpose(1, 0, 2)
    v = pvloss(pp).ravel()
    imin = jp.argmin(v)
    if v[imin] < bsf:
        bsf = v[imin]
        bsf_params = p[:, imin]
    sps = round_size * i / (time.time() - tik)
    pbar.set_description(f'loss {bsf:0.3f}, {sps:0.1g} s/s, sd {sd}')
print('final params', bsf_params)

# now show the opt sim fc found
pl.figure()
_, bsf_psd = run_sim_psd(bsf_params)
pl.semilogy(ftfreq[ftfreq>0], psds[0][1][ftfreq>0])
pl.semilogy(ftfreq[ftfreq>0], bsf_psd[ftfreq>0])
pl.xlim([0, 50])
pl.grid(1)
pl.legend(('Target', 'Fit', 'BestFit'))
pl.ylabel('PSD')
pl.xlabel('Hz')
pl.title('Simulated PSDs & Fit')

pl.show()
