"""
The goal of this example is to create a model of power spectral densities
generated by the Jansen-Rit model, and to estimate parameters corresponding
to different PSDs.

- fsamp 500 Hz, win 4s, overlap 1s, Welsh PSD, log dB, 60 s data

"""

import time
import numpy as np
import pylab as pl
import vbjax as vb
import jax
import jax.numpy as jp
import jax.example_libraries.optimizers as jopt
import tqdm

# first model will just be a single Jansen-Rit
def model(state, parameters):
    return vb.jr_dfun(state, 0, parameters)

# define a function to run the simulation & compute Welch PSD
def run_sim_psd(parameters, rng_key):

    # here we are choosing 4 parameters to optimize, but
    # it's best to look at the paper to select the best ones for your study
    A, B, a, b, lsig = parameters 

    # do a short simulation
    dt = 2.0 # ms == 500 Hz sampling frequency
    ntime = int(60e3 / dt)
    initial_state = jp.ones((6, 1))
    _, loop = vb.make_sde(dt=dt, dfun=model, gfun=jp.exp(lsig))
    noise = vb.randn(ntime, *initial_state.shape, key=rng_key)
    parameters = vb.jr_default_theta._replace(A=A, B=B, a=a, b=b)
    states = loop(initial_state, noise, parameters)
    lfp = states[:, 1] - states[:, 0]
    lfp = jp.diff(lfp, axis=0) # remove 1/f

    # compute spectra
    win_size = int(4e3 / dt)
    overlap = win_size // 4 # 25 %
    ftfreq = jp.fft.fftfreq(win_size, dt) * 1e3 # kHz -> Hz

    windows = jp.array([lfp[i*overlap:i*overlap+win_size,0]
                        for i in range((len(lfp) - win_size)//overlap)])
    windows = windows * jp.hanning(win_size)
    windows_fft = jp.fft.fft(windows, axis=1)  # apply fft over time
    windows_psd = jp.mean(jp.abs(windows_fft), axis=0) # average power
    return ftfreq, windows_psd


# run sim for two example parameters
parameters = [
    (3.25, 22.0, 0.1, 0.05, -8.0),
    (3.25, 22.0, 0.1, 0.05, -7.0),
    (3.31, 22.5, 0.11, 0.049, -8.0),
    ]
rng_keys = jax.random.split(jax.random.PRNGKey(1106), len(parameters))
psds = [run_sim_psd(p, k) for p, k in zip(parameters, rng_keys)]

# show those psds
pl.figure()
ftfreq = psds[0][0]
ftmask = (ftfreq > 0)*(ftfreq < 80)
for _, psd in psds:
    pl.semilogy(ftfreq[ftmask], psd[ftmask])
pl.xlim([0, 50])
pl.grid(1)
pl.legend([str(_) for _ in parameters])
pl.ylabel('PSD')
pl.xlabel('Hz')
pl.title('Example Simulated Welch PSD on 60s Jansen-Rit')


# sbi requires sampling parameter space
param_lo = jp.r_[3.0, 20.0, 0.05, 0.01, -9.0]
param_hi = jp.r_[3.5, 25.0, 0.2, 0.1, -5.0]

prun = jax.pmap(jax.vmap(lambda p,k: run_sim_psd(p,k)[1], in_axes=(1,0), out_axes=1))

rounds = 128
rng_keys = jax.random.split(jax.random.PRNGKey(1106), rounds)
params = []
psds = []
for i, round_key in enumerate(pbar := tqdm.tqdm(rng_keys)):
    keys_i = jax.random.split(round_key, 1 + vb.cores*16)
    param_key = keys_i[0]
    sim_keys = keys_i[1:].reshape(vb.cores, 16, 2)
    param_i = jax.random.uniform(
            key=param_key,
            shape=(vb.cores, param_lo.size, 16),
            minval=param_lo[:,None],
            maxval=param_hi[:,None])
    psd_i = prun(param_i, sim_keys)[:, ftmask]
    params.append(param_i)
    psds.append(psd_i)
    if i % 10 == 0:
        pbar.set_description(f'sbi sim batch {i}')
params = jp.array(params).reshape(-1, param_lo.size, 16).transpose(0,2,1).reshape(-1, param_lo.size)
psds = jp.array(psds).reshape(-1, ftmask.sum(), 16).transpose(0,2,1).reshape(-1, ftmask.sum())

# now we do a Bayesian regression
betas = jp.ones((2, params.shape[1], psds.shape[1]))*1e-6
def loss(betas):
    bmean, blsd = betas
    mean = psds @ bmean.T
    lsd = psds @ blsd.T
    lp_per = jax.scipy.stats.norm.logpdf(params, mean, jp.exp(lsd))
    lsd_regu = jax.scipy.stats.norm.logpdf(lsd, jp.log((param_hi - param_lo)/5), 1)
    return -(jp.mean(lp_per) + jp.mean(lsd_regu))

vgloss = jax.jit(jax.value_and_grad(loss))
v, g = vgloss(betas)
for i in (pbar := tqdm.trange(2000)):
    v, g = vgloss(betas)
    betas = betas - 1e-6*g
    if i%10 == 0:
        pbar.set_description(f'sbi train {i} lp {v} |g| {jp.linalg.norm(g)}')

bmean, blsd = betas
par_mean = psds @ betas[0].T
par_lsd = psds @ betas[1].T
print('target lsd', jp.log((param_hi - param_lo)/5))
print('average lsd', par_lsd.mean(axis=0))
print('std lsd', par_lsd.std(axis=0))

pl.show()
